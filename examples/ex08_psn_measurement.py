#!/usr/bin/env python3
"""
Example 08 — PSN Endpoint Measurement
======================================
Demonstrates a complete measurement session in PSN Ethernet Endpoint mode:

  1. Ensure the device is in PSN_ETH_ENDPOINT mode (switch if needed).
  2. Check link status on all ports.
  3. Start monitoring (psnMonEnable = true).
  4. Poll metrics at regular intervals for a configurable duration.
  5. Stop monitoring (psnMonEnable = false).
  6. Print a final summary of the collected results.

Metrics logged per sample:
  - psnMonRateStatsTable : Ethernet frame rate, bit rate, % utilisation
                           (current, min, max since session start)
  - psnMonSlaStatsTable  : Frame Transfer Delay (FTD), Frame Delay Variation
                           (FDV/jitter), lost frames, Frame Loss Ratio (FLR)
  - psnMonErrorStatsTable: FCS errors, undersized frames, oversized frames

Final summary reads:
  - psnMonStatsTable     : total frames and bytes for the session
  - psnMonEthStatsTable  : unicast / multicast / broadcast breakdown
  - psnMonIpStatsTable   : IPv4 / IPv6 / UDP / ICMP counts

Usage:
    python ex08_psn_measurement.py <device_ip> [duration_seconds]

    duration_seconds defaults to 30 if not provided.

Note:
    Requires traffic to be present on the Ethernet port for SLA metrics
    (FTD, FDV, lost) to be meaningful. FTD and FDV are only computed for
    test frames generated by the paired endpoint, not arbitrary traffic.
"""

import asyncio
import sys
from pathlib import Path
from datetime import datetime

sys.path.insert(0, str(Path(__file__).parent.parent / 'src'))
from albedo_snmp_core import MultifunctionDevice, FunctionType


DEVICE_IP       = sys.argv[1] if len(sys.argv) > 1 else '192.168.1.100'
DURATION        = int(sys.argv[2]) if len(sys.argv) > 2 else 30
SAMPLE_INTERVAL = 5   # seconds between metric reads during the session

MIB = 'ATSL-PSN-MONITOR-MIB'

# TruthValue encoding (SNMPv2-TC)
TRUE  = 1
FALSE = 2

LINK_STATUS = {0: '10 Mbps', 1: '100 Mbps', 2: '1000 Mbps', 3: '10 Gbps', 4: 'No link'}


# ---------------------------------------------------------------------------
# Helper: read a single block row from a table (index = row_index)
# ---------------------------------------------------------------------------
async def read_row(device, table_name, row_index):
    """Walk a table and return the row matching row_index as {col_name: value}."""
    rows = await device.walk(MIB, table_name)
    data = {}
    for oid_str, value in rows:
        parts = oid_str.split('.')
        try:
            row = int(parts[-1])
            if row == row_index:
                # Use last two components as key: col_name is in the OID prefix
                # but since we only have numeric OIDs here, store by position
                data[oid_str] = value
        except (ValueError, IndexError):
            continue
    return data


# ---------------------------------------------------------------------------
# Phase 1: link status check
# ---------------------------------------------------------------------------
async def check_link_status(device):
    print("\n--- Link Status ---")
    rows = await device.walk(MIB, 'psnLinkStatusTable')

    # Parse rows: OID ends in <col>.<row>
    # col 2 = psnLinkStatusName, col 3 = psnLinkStatusValue
    names  = {}
    values = {}
    for oid_str, value in rows:
        parts = oid_str.split('.')
        try:
            col = int(parts[-2])
            row = int(parts[-1])
            if col == 2:
                names[row]  = str(value)
            elif col == 3:
                values[row] = int(value)
        except (ValueError, IndexError):
            continue

    if not names:
        print("  (no link status entries)")
        return

    for row in sorted(names):
        name   = names.get(row, f'port{row}')
        status = LINK_STATUS.get(values.get(row, 4), 'unknown')
        print(f"  {name}: {status}")


# ---------------------------------------------------------------------------
# Phase 2: sample metrics during the measurement
# ---------------------------------------------------------------------------
async def sample_metrics(device, sample_num):
    """Read and print rate and SLA stats for block index 1."""
    print(f"\n  [Sample {sample_num}]")

    # Rate stats (block index 1) — psnMonRateStatsTable
    # Key columns: EthBps(4), EthPercent(5), EthMinBps(7), EthMaxBps(10)
    rate_rows = await device.walk(MIB, 'psnMonRateStatsTable')
    rate = {}
    for oid_str, value in rate_rows:
        parts = oid_str.split('.')
        try:
            col = int(parts[-2])
            row = int(parts[-1])
            if row == 1:
                rate[col] = int(value)
        except (ValueError, IndexError):
            continue

    if rate:
        bps     = rate.get(4, 0)
        pct     = rate.get(5, 0) / 1000.0   # RatioPercentage is x1000
        min_bps = rate.get(7, 0)
        max_bps = rate.get(10, 0)
        fps     = rate.get(3, 0)
        print(f"    Rate     : {fps} fps  |  {bps:,} bps  |  {pct:.2f}%")
        print(f"    Min/Max  : {min_bps:,} / {max_bps:,} bps")

    # SLA stats (block index 1) — psnMonSlaStatsTable
    # Key columns: FtdMean(6), FdvMean(11), Lost(14), Flr(15)
    sla_rows = await device.walk(MIB, 'psnMonSlaStatsTable')
    sla = {}
    for oid_str, value in sla_rows:
        parts = oid_str.split('.')
        try:
            col = int(parts[-2])
            row = int(parts[-1])
            if row == 1:
                sla[col] = int(value)
        except (ValueError, IndexError):
            continue

    if sla:
        ftd_mean = sla.get(6, 0)    # µs
        fdv_mean = sla.get(11, 0)   # µs
        lost     = sla.get(14, 0)
        flr      = sla.get(15, 0) / 1000.0   # RatioPercentage
        print(f"    FTD mean : {ftd_mean} µs")
        print(f"    FDV mean : {fdv_mean} µs")
        print(f"    Lost     : {lost} frames  |  FLR: {flr:.3f}%")

    # Error stats (block index 1) — psnMonErrorStatsTable
    # Key columns: FCS(19), UnderS(3), OverS(6)
    err_rows = await device.walk(MIB, 'psnMonErrorStatsTable')
    err = {}
    for oid_str, value in err_rows:
        parts = oid_str.split('.')
        try:
            col = int(parts[-2])
            row = int(parts[-1])
            if row == 1:
                err[col] = int(value)
        except (ValueError, IndexError):
            continue

    if err:
        fcs    = err.get(19, 0)
        under  = err.get(3, 0)
        over   = err.get(6, 0)
        print(f"    FCS err  : {fcs}  |  Undersized: {under}  |  Oversized: {over}")


# ---------------------------------------------------------------------------
# Phase 3: final summary
# ---------------------------------------------------------------------------
async def print_summary(device):
    print("\n=== Final Summary ===")

    # General stats: total frames and bytes (psnMonStatsTable)
    # col 3 = frames, col 4 = bytes
    stats_rows = await device.walk(MIB, 'psnMonStatsTable')
    stats = {}
    for oid_str, value in stats_rows:
        parts = oid_str.split('.')
        try:
            col = int(parts[-2])
            row = int(parts[-1])
            if row == 1:
                stats[col] = int(value)
        except (ValueError, IndexError):
            continue

    if stats:
        frames = stats.get(3, 0)
        byt    = stats.get(4, 0)
        print(f"  Total frames : {frames:,}")
        print(f"  Total bytes  : {byt:,}")

    # Ethernet breakdown (psnMonEthStatsTable)
    # col 3=unicast, col 4=multicast, col 5=broadcast, col 6=vlan
    eth_rows = await device.walk(MIB, 'psnMonEthStatsTable')
    eth = {}
    for oid_str, value in eth_rows:
        parts = oid_str.split('.')
        try:
            col = int(parts[-2])
            row = int(parts[-1])
            if row == 1:
                eth[col] = int(value)
        except (ValueError, IndexError):
            continue

    if eth:
        print(f"  Unicast      : {eth.get(3, 0):,} frames")
        print(f"  Multicast    : {eth.get(4, 0):,} frames")
        print(f"  Broadcast    : {eth.get(5, 0):,} frames")
        print(f"  VLAN-tagged  : {eth.get(6, 0):,} frames")

    # IP breakdown (psnMonIpStatsTable)
    # col 3=ipv4, col 5=ipv6, col 10=udp, col 12=icmp
    ip_rows = await device.walk(MIB, 'psnMonIpStatsTable')
    ip = {}
    for oid_str, value in ip_rows:
        parts = oid_str.split('.')
        try:
            col = int(parts[-2])
            row = int(parts[-1])
            if row == 1:
                ip[col] = int(value)
        except (ValueError, IndexError):
            continue

    if ip:
        print(f"  IPv4 packets : {ip.get(3, 0):,}")
        print(f"  IPv6 packets : {ip.get(5, 0):,}")
        print(f"  UDP packets  : {ip.get(10, 0):,}")
        print(f"  ICMP packets : {ip.get(12, 0):,}")


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------
async def main():

    print("=" * 60)
    print("PSN ENDPOINT MEASUREMENT")
    print("=" * 60)
    print(f"Device   : {DEVICE_IP}")
    print(f"Duration : {DURATION}s  (sample every {SAMPLE_INTERVAL}s)")
    print(f"Started  : {datetime.now().strftime('%H:%M:%S')}")

    async with MultifunctionDevice(DEVICE_IP) as device:

        # Step 1: ensure PSN Ethernet Endpoint mode
        print("\n--- Mode Check ---")
        ok = await device.ensure_function(FunctionType.PSN_ETH_ENDPOINT)
        if not ok:
            print("Could not switch to PSN_ETH_ENDPOINT mode — aborting.")
            return
        active = await device.get_active_function()
        print(f"Active mode: {active.name}")

        # Step 2: check link status before starting
        await check_link_status(device)

        # Step 3: start monitoring
        print("\n--- Starting Monitoring ---")
        started = await device.set(MIB, 'psnMonEnable', TRUE, 0)
        if not started:
            print("Failed to enable monitoring — aborting.")
            return
        print("psnMonEnable = true")

        # Step 4: sample loop
        print(f"\n--- Sampling ({DURATION}s) ---")
        elapsed = 0
        sample_num = 0
        while elapsed < DURATION:
            await asyncio.sleep(SAMPLE_INTERVAL)
            elapsed += SAMPLE_INTERVAL
            sample_num += 1
            await sample_metrics(device, sample_num)

        # Step 5: stop monitoring
        print("\n--- Stopping Monitoring ---")
        await device.set(MIB, 'psnMonEnable', FALSE, 0)
        print("psnMonEnable = false")

        # Step 6: final summary
        await print_summary(device)

    print(f"\nFinished : {datetime.now().strftime('%H:%M:%S')}")


if __name__ == '__main__':
    asyncio.run(main())